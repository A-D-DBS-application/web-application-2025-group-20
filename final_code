import requests
import re
from dataclasses import dataclass
from typing import Optional, List

jwt_token = "eyJhbGciOiJSUzI1NiJ9.eyJ0ZWFtIjoxNTM5OTY1MTk3LCJpYXQiOjE3NjQ4NjEzODMsImlzcyI6ImJpenp5OnB1YmxpYy1hcGkiLCJzdWIiOiIxNTM5OTY1MTk3In0.U34ClDcN5YZzDbkNSxQlGcLLvfn-V0m8iAh-fJwMiml2FQpo9nb9elgxoA7Qg5yn6VDopyq9tqTUk-ezTjrn-m-ixJLxe4CHKMuRDk2sgo5jBLWrxQgTLwFqLKQyxraUcJnVYh6nI8l11nLZT-X2-p0Z1gf6LP1HWs1Y0SWlfd6-Ci8qro7wyAQSplj22KiJ2Aphmm695elV8A4Wii4DIG2AgWB_goXfbs0fWoAh4aQLZxgOsdkyo4IbQNP-SAdHb2J_CYaGqsqkF6amxSfGT8Y-OJOZaT-zqLbmMy6p5c-vAG9HkusypDoToNg5bUpl84bPKEWNystRoUSimnTgyA"
url = "https://api.bizzy.ai/v1/companies/BE/"

def getData(bedrijfsnummer) -> str:

    headers = {
        "Authorization": f"Bearer {jwt_token}",
        "Accept": "application/json"
    }

    response = requests.get(url + bedrijfsnummer + "/financials", headers=headers)

    if response.status_code != 200:
        raise Exception(response.status_code, response.text)
    return response.json()

def clean_vat_number(raw: str) -> str:

    digits = re.sub(r"\D", "", raw)

    if len(digits) == 10 and digits.startswith("0"):
        digits = digits[1:]

    if len(digits) != 9:
        raise ValueError(
            f"Ongeldig BTW-nummer: verwacht 9 cijfers, kreeg {len(digits)} ({digits})"
        )
    return digits

@dataclass
class AnnualAccount:
    year: int
    health_indicator: int

    # Profitability
    revenue: float
    gross_margin: float
    ebitda: float
    ebit: float
    net_profit: float

    # Liquidity
    cash: float
    cash_flow: float
    nwc: float
    nwcr: float
    current_ratio: float
    quick_ratio: float

    # Solvency
    total_assets: float
    equity: float
    capital: float
    retained_earnings: float
    debt: float
    long_term_debt: float
    short_term_debt: float

    # People
    employees: float
    new_hires: int
    male_ratio: float
    female_ratio: float

    SOLVENCY_RANGES = {
        "cf_coverage": (0, 3, False),        # hoger = beter
        "net_leverage": (0, 6, True),        # lager = beter
        "lt_independence": (0, 0.6, False),  # hoger = beter
        "ebitda_mult": (0, 10, True),        # lager = beter
        "current_ratio": (0, 3, False),      # hoger = beter
        "quick_ratio": (0, 2.5, False),      # hoger = beter
    }

    SOLVENCY_WEIGHTS = {
        "cf_coverage": 0.18,
        "net_leverage": 0.23,
        "lt_independence": 0.28,
        "ebitda_mult": 0.14,
        "current_ratio": 0.09,
        "quick_ratio": 0.08,
    }
    @staticmethod
    def normalize(value, min_val, max_val, inverse=False):
        """Normaliseer indicatoren naar schaal 0–1."""
        if value is None:
            return 0.0
        if value < min_val:
            value = min_val
        if value > max_val:
            value = max_val

        norm = (value - min_val) / (max_val - min_val)
        return 1 - norm if inverse else norm
    
    def compute_model_solvency(self) -> float:
        cf_coverage = (self.cash_flow - self.cash) / self.long_term_debt if self.long_term_debt else 0.0
        net_leverage = (self.debt - self.cash) / self.equity if self.equity else 0.0
        lt_independence = self.equity / (self.long_term_debt + self.equity) if (self.long_term_debt + self.equity) else 0.0
        ebitda_mult = self.debt / self.ebitda if self.ebitda else 0.0

        cr = self.current_ratio or 0.0
        qr = self.quick_ratio or 0.0

        cf_norm = self.normalize(cf_coverage, *self.SOLVENCY_RANGES["cf_coverage"])
        nl_norm = self.normalize(net_leverage, *self.SOLVENCY_RANGES["net_leverage"])
        lt_norm = self.normalize(lt_independence, *self.SOLVENCY_RANGES["lt_independence"])
        em_norm = self.normalize(ebitda_mult, *self.SOLVENCY_RANGES["ebitda_mult"])
        cr_norm = self.normalize(cr, *self.SOLVENCY_RANGES["current_ratio"])
        qr_norm = self.normalize(qr, *self.SOLVENCY_RANGES["quick_ratio"])

        score = (
            cf_norm * self.SOLVENCY_WEIGHTS["cf_coverage"] +
            nl_norm * self.SOLVENCY_WEIGHTS["net_leverage"] +
            lt_norm * self.SOLVENCY_WEIGHTS["lt_independence"] +
            em_norm * self.SOLVENCY_WEIGHTS["ebitda_mult"] +
            cr_norm * self.SOLVENCY_WEIGHTS["current_ratio"] +
            qr_norm * self.SOLVENCY_WEIGHTS["quick_ratio"]
        )
        return score
    
    def pretty_print(self):
        print(f"Solvency ratio {self.year}: {self.equity / self.total_assets if self.total_assets else 0.0}")                                   #Graad van eigen vermogen tov totale activa (>) %                 
        print(f"Dekking van het vreemd vermogen op langetermijn door de cashflow {self.year}: {(self.cash_flow - self.cash)/ self.long_term_debt if self.long_term_debt else 0.0}")                                    #afloscapaciteit van langetermijnschulden met operationele cashflow (>) %
        print(f"Netto financiele schuldgraad {self.year}: {(self.debt - self.cash) / self.equity if self.equity else 0.0}")                                                 #Graad van schulden niet af te betalen met beschikbare liquide middelen (<) x                 
        print(f"Langetermijngraad van financiele onafhankelijkheid {self.year}: {self.equity / (self.long_term_debt + self.equity) if (self.long_term_debt + self.equity) else 0.0}")                                 #Graad van financiering met eigenvermogen ipv schulden (>) %
        print(f"EBITDA multiplicator van het netto financieel vreemd vermogen {self.year}: {self.debt / self.ebitda if self.ebitda else 0.0}")                                    #Aantal jaren nodig om de netto financiële schuld af te lossen met de EBITDA (<) x
        print(f"Current ratio {self.year}: {self.current_ratio}")                                         #Current ratio (>) x
        print(f"Quick ratio {self.year}: {self.quick_ratio}")                                             #Quick ratio (>) x
        print(f" Model Solvency Score {self.year}: {self.compute_model_solvency():.4f}")
        print("-------------------------------")

def parse_financials_to_classes(data: dict) -> List[AnnualAccount]:
    accounts = []
    identifier = data.get("identifier", {})
    name = identifier.get("name")
    for item in data.get("data", []):
        start_date = item.get("startDate")
        year = int(start_date.split("-")[0]) if start_date else None

        profitability = item.get("profitability", {})
        liquidity = item.get("liquidity", {})
        solvency = item.get("solvency", {})
        people = item.get("people", {})

        accounts.append(
            AnnualAccount(
                year=year,
                health_indicator=item.get("healthIndicator"),

                # Profitability
                revenue=profitability.get("revenue"),
                gross_margin=profitability.get("grossMargin"),
                ebitda=profitability.get("ebitda"),
                ebit=profitability.get("ebit"),
                net_profit=profitability.get("netProfit"),

                # Liquidity
                cash=liquidity.get("cash"),
                cash_flow=liquidity.get("cashFlow"),
                nwc=liquidity.get("netWorkingCapital"),
                nwcr=liquidity.get("netWorkingCapitalRequirement"),
                current_ratio=liquidity.get("currentRatio"),
                quick_ratio=liquidity.get("quickRatio"),

                # Solvency
                total_assets=solvency.get("totalAssets"),
                equity=solvency.get("equity"),
                capital=solvency.get("capital"),
                retained_earnings=solvency.get("retainedEarnings"),
                debt=solvency.get("debt"),
                long_term_debt=solvency.get("longTermDebt"),
                short_term_debt=solvency.get("shortTermDebt"),

                # People
                employees=people.get("employees"),
                new_hires=people.get("newHires"),
                male_ratio=people.get("employeeMaleRatio"),
                female_ratio=people.get("employeeFemaleRatio"),
            )
        )

    return accounts

if __name__ == "__main__":
    raw_input_string = input("Gelieve één of meerdere BTW-nummers te geven (gescheiden door komma's): ")
    raw_numbers = [x.strip() for x in raw_input_string.split(",") if x.strip()]
    for raw in raw_numbers:
        try:
            nummer = clean_vat_number(raw)
        except ValueError as e:
            print(f"\nOngeldig BTW-nummer ({raw}): {e}")
            continue

        data = getData(nummer)

        try:
            company_name = data.get("identifier", {}).get("name", nummer)
            accounts = parse_financials_to_classes(data)
        except AttributeError as e:
            print(f"\nKon data niet ophalen voor {nummer}")
            continue

        if not accounts:
            print(f"\nGeen financiële gegevens gevonden voor {company_name}.")
        else:
            print(f"\nFinanciële gegevens voor {company_name}:")
            for acc in sorted(accounts, key=lambda x: x.year, reverse=True):
                acc.pretty_print()

#testnummers: 0416375270,0403.199.702,BE5,770493071,0123456789,012345678
